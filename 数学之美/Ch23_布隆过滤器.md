**目录**

1. 用途
2. 原理
	- 过滤器建立过程
	- 查询过程
3. 评价
4. 误判率问题

# 1. 用途
**判断一个元素是否在集合中**。

比如我们判断一个url是否被访问过，通常的做法是建立一个集合，将被访问过的url的指纹（哈希值）存放到集合里。然后对于当前的url计算哈希值，然后判断其是否在集合里。当这个集合非常大时，所需要的存储空间也是相当大的。

假设我们要存储一亿个email地址，每个地址被哈希成8字节指纹，再加上哈希表存储空间一般只有50%（集合在计算机中一般使用哈希表表示），因此需要1.6G，即16亿字节。

我们使用布隆过滤器，可以只要哈希表大约1/8到1/4的大小就能解决同样的问题。
# 2. 原理
## （1）过滤器建立过程
它需要设置一个**很长的二进制向量**和一系列的**哈希函数**。

以存储1亿个email为例，布隆过滤器的**建立**或**插入**过程：

1. 建立一个16亿比特的向量，每个比特位清零。
2. 对每个电子邮件，使用8个不同的哈希函数`(F1,F2,...,F8)`产生8个指纹`(f1,f2,...,f8)`。
3. 再用一个哈希函数`G`将每个指纹映射为一个值域为1~16亿的自然数。于是我们得到`g1,g2,...,g8`,每个数字代表16亿比特向量第某个比特位。
4. 将得到的8个位置的比特位置1。

![Imgur](http://i.imgur.com/jotFKgP.png)

## （2）查询过程
对一个新的电子邮件Y，

1. 使用上面的8个不同哈希函数`(F1,F2,...,F8)`产生8个指纹`(f1,f2,...,f8)`。
2. 再用哈希函数`G`将每个指纹映射为一个值域为1~16亿的自然数。于是我们得到`g1,g2,...,g8`,每个数字代表16亿比特向量第某个比特位。
3. 检测这8个位置的比特位置是否都为1。如果是，很可能它已经在集合里；如果不是，则它一定不在集合里。

# 3. 评价
**好处**：

1. 快速；
2. 省空间。

**坏处**：

1. 有一定的误判率。可以建立一个白名单存储那些可能被误判的元素。
2. 无法删除元素。

# 4. 误判率问题
假定过滤器内有`m`比特，里面有`n`个元素，每个元素对应`k`个哈希函数。假阳性概率（误判率）为：

![Imgur](http://i.imgur.com/ngjSrpB.png)

（公式推导见《数学之美》第二版P206）

```
import math

def error_rate(k, n, m):
    return (1-math.e**(-k*n/m))**k
```

在上面的例子中，`k=8, n=1e8, m=16e8`，误判率在万分之五左右。

